#+TITLE: Project Canon - Example
#+AUTHOR: Polymuse Example
#+DATE: 2025-01-09

This is an example canon file for code projects. It demonstrates how to
track architecture decisions, style guides, and other project documentation
that the LLM can reference during code review.

* Architecture

** [Architecture] system-overview
:PROPERTIES:
:ID: system-overview
:LastUpdated: 2025-01-09
:END:

*** Description
Polymuse is an Emacs minor mode that provides AI-powered over-the-shoulder
code review and writing assistance. It integrates with multiple LLM backends
and provides context-aware suggestions as you work.

*** High-Level Components
- *polymuse.el*: Core functionality, backend management, review system
- *canon.el*: Entity tracking for both prose and code projects
- *typewrite.el*: Animated text output for pleasant UX
- Backend adapters: Integration with gptel for LLM communication

*** Data Flow
1. User edits code/prose in a buffer with polymuse-mode enabled
2. Periodic timer triggers review based on configured interval
3. Context extraction: grabs current unit (function/paragraph) plus surrounding context
4. Prompt composition: combines mode-specific prompt, instructions, and context
5. LLM request: sent via gptel to configured backend
6. Response handling: typewriter animation in side window

*** Key Design Decisions
- Stateless reviewers: Each review is independent, no conversation history
- Unit-based context: Uses semantic units (functions, paragraphs) not arbitrary line counts
- Tool profiles: Automatic tool registration based on active modes
- Safe suggestions: Canon tools append suggestions, never modify directly

** [Architecture] tool-system
:PROPERTIES:
:ID: tool-system
:LastUpdated: 2025-01-09
:END:

*** Description
Polymuse uses a three-layer tool system to give the LLM access to
project-specific information without hardcoding capabilities.

*** Three Layers
1. *Built-in tools*: Auto-registered based on active minor modes
   - canon-mode active → entity lookup tools
   - Future: git-mode → repo history tools
2. *Profile tools*: Named collections for different workflows
   - prose-writing: character/location tracking
   - code-review: architecture and style guide access
   - architecture: blueprint and component specs
   - debugging: known issues and troubleshooting docs
3. *File-local tools*: Project-specific tools in .polymuse-tools.el
   - Highest precedence
   - Can override built-in or profile tools

*** Tool Structure
Tools are defined using the polymuse-tool struct:
- name: String identifier for the tool
- function: Elisp function to call
- description: LLM-facing documentation
- arguments: List of parameter symbols

*** Safety Considerations
- Read-only tools: Lookup functions never modify state
- Suggestion tools: Append to dedicated sections, never clobber
- User review: All LLM modifications require manual approval

* Style Guidelines

** [Style] elisp-conventions
:PROPERTIES:
:ID: elisp-conventions
:LastUpdated: 2025-01-09
:END:

*** Description
Coding conventions for Polymuse Elisp code.

*** Naming Conventions
- Private functions: Use double-dash prefix (e.g., polymuse--internal-function)
- Public API: No prefix beyond package name (e.g., polymuse-add-reviewer)
- Buffer-local variables: Use defvar-local
- Constants: Use defcustom for user-configurable values

*** Documentation
- Every public function must have a docstring
- Private functions should have docstrings for complex logic
- Use Commentary section for high-level module documentation
- Include usage examples in docstrings for interactive commands

*** Code Organization
- Group related functions together with comment headers
- Put internal/private functions before public API
- Define structs (cl-defstruct) near the top of the file
- Use cl-lib for list/sequence operations, avoid -dash unless necessary

*** Error Handling
- Use user-error for user-facing errors (wrong input, missing config)
- Use error for programmer errors (wrong types, violated invariants)
- Provide helpful error messages with context

*** Testing Philosophy
- Critical functions should have unit tests
- Integration tests for end-to-end workflows
- Manual testing for UI/UX features

** [Style] commit-conventions
:PROPERTIES:
:ID: commit-conventions
:LastUpdated: 2025-01-09
:END:

*** Description
Git commit conventions for the Polymuse project.

*** Commit Message Format
- First line: Imperative mood, capitalized, no period, max 50 chars
- Body: Wrap at 72 chars, explain *why* not *what*
- Examples:
  - "Add tool profile system for context-specific LLM capabilities"
  - "Fix buffer truncation to preserve visible window positions"

*** Commit Scope
- One logical change per commit
- Don't mix refactoring with feature additions
- Don't mix formatting changes with logic changes

*** Branch Strategy
- Main branch: stable, always deployable
- Feature branches: claude/* prefix for AI-generated work
- Pull requests: Required for all changes to main

* Troubleshooting

** [Troubleshooting] common-issues
:PROPERTIES:
:ID: common-issues
:LastUpdated: 2025-01-09
:END:

*** LLM Response Parsing Errors
*Symptom:* Error messages about JSON parsing failures

*Cause:* The LLM returned malformed JSON or included extra text outside the JSON object

*Solution:*
- Check polymuse-debug-buffer for the raw response
- Adjust system prompt to emphasize JSON-only responses
- Consider response preprocessing to extract JSON from markdown code blocks

*** Context Too Large
*Symptom:* Reviews fail or return truncated responses

*Cause:* Context exceeds LLM's token limit

*Solution:*
- Reduce polymuse-max-prompt-characters
- Reduce polymuse-default-review-context-lines
- Break up large functions/paragraphs into smaller units

*** Canon File Not Found
*Symptom:* "Can't open canon-file, not defined" error

*Cause:* canon-file variable not set for the buffer

*Solution:*
- Set canon-file manually: (setq-local canon-file "/path/to/canon.org")
- Or let canon-mode prompt you on first use
- Add to .dir-locals.el for project-wide canon file
